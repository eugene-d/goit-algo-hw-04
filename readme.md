# Висновки та рекомендації

## Спостереження про алгоритми

- **Insertion Sort**  
  - Швидкий на малих масивах або відсортованих даних  
  - Повільний на великих випадкових масивах (O(n²))  

- **Merge Sort**  
  - Стабільний алгоритм зі складністю O(n log n)  
  - Добре працює на великих масивах  
  - Потребує додаткової пам’яті  

- **Timsort (Python)**  
  - Найшвидший у більшості випадків  
  - Адаптується до структури даних  
  - Використовує частково відсортовані сегменти  
  - Оптимізований на C  

## Практичні поради

1. Для роботи використовуйте `sorted()` або `.sort()`.  
2. Для навчання алгоритмів вивчайте **Merge Sort** як еталон O(n log n).  
3. Для масивів < 50 елементів підійде **Insertion Sort**.  
4. **Timsort** показує силу гібридних підходів.  

## Чому Timsort ефективніший

- Поєднує:  
  - **Insertion Sort** для малих сегментів  
  - **Merge Sort** для великих  
- Оптимізації:  
  - Виявлення готових відсортованих послідовностей (*runs*)  
  - Ефективне злиття сегментів (галоп-режим)  
  - Баланс швидкості та пам’яті  
- Продуктивність:  
  - На відсортованих даних працює за O(n)  
  - На частково відсортованих — максимально використовує порядок  

## Чому програмісти довіряють вбудованим алгоритмам

- Роки оптимізації та тестування  
- Реалізація на C для максимальної швидкості  
- Врахування архітектури процесора  
- Надійність у крайніх випадках  

## Головний висновок

**Timsort** — приклад того, як теорія, практика та інженерні оптимізації створюють найефективніший алгоритм.
